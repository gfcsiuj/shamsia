
import React, { createContext, useContext, useEffect, useState, useRef } from 'react';
import { useLocation } from 'react-router-dom';
import { db } from '../lib/firebase';

interface StyleOverride {
  selector: string;
  styles: Record<string, string>;
  text?: string;
}

interface VisualEditContextType {
  isEditing: boolean;
  overrides: StyleOverride[];
  toggleEditMode: () => void;
  saveOverride: (override: StyleOverride) => void;
  saveAllChanges: () => Promise<void>;
  loading: boolean;
}

const VisualEditContext = createContext<VisualEditContextType>({
  isEditing: false,
  overrides: [],
  toggleEditMode: () => {},
  saveOverride: () => {},
  saveAllChanges: async () => {},
  loading: true,
});

export const useVisualEdit = () => useContext(VisualEditContext);

export const VisualEditProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [overrides, setOverrides] = useState<StyleOverride[]>([]);
  const [loading, setLoading] = useState(true);
  const location = useLocation();
  const observerRef = useRef<MutationObserver | null>(null);

  // 1. Activate Edit Mode from URL
  useEffect(() => {
    const params = new URLSearchParams(location.search);
    setIsEditing(params.get('visualEdit') === 'true');
  }, [location]);

  // 2. Fetch Overrides from Firebase (Ensuring latest data)
  useEffect(() => {
    const fetchOverrides = async () => {
      try {
        // Use snapshot to get real-time updates across tabs/reloads
        const unsubscribe = db.collection('site_settings').doc('visual_overrides')
          .onSnapshot((doc) => {
            if (doc.exists) {
              const data = doc.data();
              if (data && data.overrides) {
                console.log("Visual Editor: Overrides loaded", data.overrides);
                setOverrides(data.overrides);
              }
            } else {
                setOverrides([]);
            }
            setLoading(false);
          });
        return () => unsubscribe();
      } catch (error) {
        console.error("Error loading visual overrides:", error);
        setLoading(false);
      }
    };

    fetchOverrides();
  }, []);

  // 3. Inject CSS Styles
  useEffect(() => {
    const styleId = 'visual-editor-global-styles';
    let styleTag = document.getElementById(styleId);
    
    if (!styleTag) {
      styleTag = document.createElement('style');
      styleTag.id = styleId;
      document.head.appendChild(styleTag);
    }

    let css = '/* Generated by Shamsia Visual Editor */\n';
    overrides.forEach(item => {
      if (item.styles && Object.keys(item.styles).length > 0) {
          const styleString = Object.entries(item.styles)
            .map(([key, value]) => {
                const val = (value as string).includes('!important') ? value : `${value} !important`;
                return `${key}: ${val};`;
            })
            .join(' ');
          
          if (styleString) {
            css += `${item.selector} { ${styleString} }\n`;
          }
      }
    });

    styleTag.textContent = css;
  }, [overrides]);

  // 4. Apply Text Overrides (High-Frequency Enforcement)
  useEffect(() => {
    const applyChanges = () => {
        overrides.forEach(override => {
            if (override.text !== undefined && override.text !== null) {
                try {
                    const elements = document.querySelectorAll(override.selector);
                    elements.forEach(el => {
                        if (el instanceof HTMLElement) {
                             // Clean and strict comparison to avoid loops
                             const current = el.innerText;
                             const target = override.text as string;
                             
                             if (current !== target) {
                                 el.innerText = target;
                             }
                        }
                    });
                } catch (e) {
                    // Ignore selector errors
                }
            }
        });
    };

    // Apply immediately and aggressively on load
    applyChanges();
    const interval = setInterval(applyChanges, 500); // Fallback for React hydration

    // Setup Observer
    if (observerRef.current) {
        observerRef.current.disconnect();
    }

    observerRef.current = new MutationObserver(() => {
        applyChanges();
    });

    observerRef.current.observe(document.body, {
        childList: true,
        subtree: true,
        characterData: true
    });

    return () => {
        clearInterval(interval);
        if (observerRef.current) {
            observerRef.current.disconnect();
        }
    };
  }, [overrides, location.pathname]); // Re-apply on route change


  const saveOverride = (newOverride: StyleOverride) => {
    setOverrides(prev => {
      const updated = [...prev];
      const index = updated.findIndex(o => o.selector === newOverride.selector);
      
      if (index > -1) {
        updated[index] = {
            ...updated[index],
            styles: { ...updated[index].styles, ...newOverride.styles },
            text: newOverride.text !== undefined ? newOverride.text : updated[index].text
        };
      } else {
        updated.push(newOverride);
      }
      return updated;
    });
  };

  const saveAllChanges = async () => {
    try {
      // Firebase throws an error if any field is undefined.
      // We must clean the overrides array before saving.
      const cleanOverrides = overrides.map(o => {
        const cleanObj: any = { 
            selector: o.selector, 
            styles: o.styles || {}
        };
        // Only include text if it is defined and not null
        if (o.text !== undefined && o.text !== null) {
            cleanObj.text = o.text;
        }
        return cleanObj;
      }).filter(o => 
        (Object.keys(o.styles).length > 0) || (o.text !== undefined && o.text !== '')
      );
      
      await db.collection('site_settings').doc('visual_overrides').set(
        { overrides: cleanOverrides }, 
        { merge: true }
      );
      console.log("Visual overrides saved to Firebase successfully.");
    } catch (e) {
      console.error("Failed to save all changes to Firebase", e);
      throw e;
    }
  };

  const toggleEditMode = () => setIsEditing(!isEditing);

  return (
    <VisualEditContext.Provider value={{ isEditing, overrides, toggleEditMode, saveOverride, saveAllChanges, loading }}>
      {children}
    </VisualEditContext.Provider>
  );
};
